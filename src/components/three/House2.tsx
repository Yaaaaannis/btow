/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useMemo } from 'react'
import { useGLTF, PerspectiveCamera, useAnimations, Html } from '@react-three/drei'
import { MeshPhysicalMaterial, DoubleSide, BufferAttribute, PointLight, HemisphereLight, Color } from 'three'
import { Object3D, Mesh, BufferGeometry, Material } from 'three'
import type { GLTF } from 'three-stdlib'
import * as THREE from "three";
import { useFrame } from "@react-three/fiber";

interface GLTFResult extends GLTF {
  nodes: {
    [key: string]: Mesh<BufferGeometry, Material | Material[]>
  }
  materials: {
    [key: string]: Material
  }
}

type MaterialMap = {
  [key: string]: Material
  glass: MeshPhysicalMaterial
}

interface House2Props {
  onLoad?: (actions: any) => void;
  [key: string]: any;
}

export function House2({ onLoad, ...props }: House2Props) {
  const group = useRef<Object3D>(null)
  const { nodes, materials, animations } = useGLTF('/museum.glb') as unknown as GLTFResult
  const { actions } = useAnimations(animations, group)

  // Expose actions to parent component
  React.useEffect(() => {
    if (onLoad && actions) {
      onLoad(actions)
    }
  }, [actions, onLoad])

  // Fonctions pour contrôler les animations
  const playBackDoorAnimation = () => {
    if (actions['Back_Door_Open.001']) {
      actions['Back_Door_Open.001'].reset().play()
    }
  }

  const playMainDoorAnimation = () => {
    if (actions['Main_Door_Open']) {
      actions['Main_Door_Open'].reset().play()
    }
  }

  // Log des meshes et animations
  React.useEffect(() => {
    console.log('=== Model Meshes ===')
    Object.keys(nodes).forEach((nodeName) => {
      console.log(`Mesh: ${nodeName}`)
    })
    
    console.log('\n=== Model Animations ===')
    if (animations && animations.length > 0) {
      animations.forEach((anim, index) => {
        console.log(`Animation ${index + 1}: ${anim.name}`)
      })
    } else {
      console.log('No animations found in the model')
    }
  }, [nodes, animations])

  // Optimiser les matériaux avec useMemo
  const optimizedMaterials = useMemo(() => {
    // Matériau de verre optimisé
    const glassMaterial = new MeshPhysicalMaterial({
      roughness: 0.1,
      transmission: 0.95,
      thickness: 0.5,
      clearcoat: 1.0,
      clearcoatRoughness: 0.1,
      ior: 1.5,
      transparent: true,
      opacity: 0.3,
      envMapIntensity: 1.5,
      attenuationColor: new Color(0xffffff),
      attenuationDistance: 0.5,
    })

    // Optimiser les autres matériaux
    Object.values(materials).forEach(material => {
      material.side = DoubleSide
      material.needsUpdate = true
      // @ts-ignore
      if (material.shadowSide === undefined) {
        // @ts-ignore
        material.shadowSide = DoubleSide
      }
    })

    return {
      glass: glassMaterial,
      ...materials
    } as MaterialMap
  }, [materials])

  // Optimiser les géométries avec useMemo
  const optimizedGeometries = useMemo(() => {
    Object.values(nodes).forEach(node => {
      if (node.geometry) {
        // Optimiser uniquement les BufferAttribute
        const position = node.geometry.attributes.position
        const normal = node.geometry.attributes.normal
        const uv = node.geometry.attributes.uv
        
        if (position instanceof BufferAttribute) position.setUsage(35044)
        if (normal instanceof BufferAttribute) normal.setUsage(35044)
        if (uv instanceof BufferAttribute) uv.setUsage(35044)
        
        // Optimiser les buffers
        node.geometry.computeBoundingSphere()
        node.geometry.computeBoundingBox()
      }
    })
    return nodes
  }, [nodes])

  // Initialiser RectAreaLightUniformsLib dynamiquement côté client
  React.useEffect(() => {
    // @ts-ignore
    import('three/examples/jsm/lights/RectAreaLightUniformsLib').then(mod => {
      mod.RectAreaLightUniformsLib.init();
    });
  }, []);

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="FUll_and_final">
        <PerspectiveCamera
          name="Camera_006"
          makeDefault={true}
          far={1000}
          near={0.1}
          fov={22.895}
          position={[25.252, 1.82, 24.882]}
          rotation={[0.103, 0.73, -0.069]}
          scale={[1, 0.979, 1]}
        />
        <PerspectiveCamera
          name="Camera_007"
          makeDefault={false}
          far={1000}
          near={0.1}
          fov={22.895}
          position={[0.771, 2.523, 8.764]}
          rotation={[0.007, 0.042, 0]}
        />
        <PerspectiveCamera
          name="Camera_008"
          makeDefault={false}
          far={1000}
          near={0.1}
          fov={22.895}
          position={[14.111, 0.474, 9.408]}
          rotation={[0.55, 1.246, -0.527]}
        />
         <PerspectiveCamera
          name="Camera_009"
          makeDefault={false}
          far={1000}
          near={0.1}
          fov={22.895}
          position={[0.887, 2.523, 1.414]}
          rotation={[0.007, 0.042, 0]}
        />
        <mesh
          name="Window_Glass"
          castShadow={false}
          receiveShadow
          geometry={nodes.Window_Glass.geometry}
          material={optimizedMaterials.glass}
          position={[0.626, 0, -1.686]}
        />
        <mesh
          name="Window_Glass_Frame"
          castShadow
          receiveShadow
          geometry={nodes.Window_Glass_Frame.geometry}
          material={optimizedMaterials['windows_frame_001_Baked_001.002']}
          position={[0.626, 0, -1.686]}
        />
        <mesh
          name="Wooden_Roof"
          castShadow
          receiveShadow
          geometry={nodes.Wooden_Roof.geometry}
          material={optimizedMaterials['roof_001_Baked_001.002']}
          position={[0.626, 0, -1.686]}
        />
        <mesh
          name="Plane_060"
          castShadow
          receiveShadow
          geometry={nodes.Plane_060.geometry}
          material={optimizedMaterials['main_frame_001_Baked_001.002']}
          position={[0.626, 0, -1.686]}
        />
        <group name="Plane_061" position={[0.626, 0, -1.686]}>
          <mesh
            name="Plane_061_1"
            castShadow
            receiveShadow
            geometry={nodes.Plane_061_1.geometry}
            material={optimizedMaterials['inner_planks_001_Baked_001.002']}
          />
          <mesh
            name="Plane_061_2"
            castShadow
            receiveShadow
            geometry={nodes.Plane_061_2.geometry}
            material={optimizedMaterials['inner_planks_001_Baked_001.001']}
          />
        </group>
        <mesh
          name="Plane_062"
          castShadow={false}
          receiveShadow
          geometry={nodes.Plane_062.geometry}
          material={optimizedMaterials['floor_001_Baked_001.002']}
          position={[0.626, 0, -1.686]}
        />
        <mesh
          name="Back_Door"
          castShadow
          receiveShadow
          geometry={nodes.Back_Door.geometry}
          material={optimizedMaterials['door_003_Baked_001.002']}
          position={[-0.208, 2.589, -12.797]}
          rotation={[Math.PI, -0.02, Math.PI]}
        />
        <mesh
          name="Main_Door"
          castShadow
          receiveShadow
          geometry={nodes.Main_Door.geometry}
          material={optimizedMaterials['door_004_Baked_001.002']}
          position={[0.086, 2.577, 1.944]}
        />
        <mesh
          name="Plane_065"
          castShadow
          receiveShadow
          geometry={nodes.Plane_065.geometry}
          material={optimizedMaterials['base_supports_001_Baked_001.002']}
          position={[-4.594, 0, 0.814]}
        />
        <mesh
          name="Plane_066"
          castShadow
          receiveShadow
          geometry={nodes.Plane_066.geometry}
          material={optimizedMaterials['base_supports_004_Baked_001.002']}
          position={[0.626, 0, -1.686]}
        />
        <mesh
          name="Plane_067"
          castShadow
          receiveShadow
          geometry={nodes.Plane_067.geometry}
          material={optimizedMaterials['base_supports_005_Baked_001.002']}
          position={[0.626, 0, -1.686]}
        />
        <mesh
          name="Plane_068"
          castShadow
          receiveShadow
          geometry={nodes.Plane_068.geometry}
          material={optimizedMaterials['base_railing_001_Baked_001.002']}
          position={[0.626, 0, -1.686]}
        />
        <mesh
          name="Plane_069"
          castShadow
          receiveShadow
          geometry={nodes.Plane_069.geometry}
          material={optimizedMaterials['base_001_Baked_001.002']}
          position={[0.626, 0, -1.686]}
        />
        <mesh
          name="Ground002"
          castShadow={false}
          receiveShadow
          geometry={nodes.Ground002.geometry}
          material={optimizedMaterials['Ground_Baked_001.002']}
          position={[-9.118, 0, -10.734]}
          scale={31.891}
        />
       
        
      </group>
       <mesh
          name="Outline_GLass_Steal"
          castShadow
          receiveShadow
          geometry={nodes.Outline_GLass_Steal.geometry}
          material={optimizedMaterials['base_railing_001_Baked_001.002']}
          position={[0.626, 0, -1.686]}
        />

      <mesh
          name="Glass"
          castShadow={false}
          receiveShadow
          geometry={nodes.Glass.geometry}
          material={optimizedMaterials.glass}
          position={[0.626, 0, -1.686]}
        />
       
      {/* Suppression des lumières locales car elles sont maintenant gérées au niveau de la scène */}
    </group>
  )
}

useGLTF.preload('/museum.glb')
